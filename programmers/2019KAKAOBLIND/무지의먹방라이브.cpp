/* ----------<문제 정의>----------
문제: 배열 1초씩 깎아서 중단 이후의 배열 인덱스
입력: 1<=k<=10조
출력: k 초 후 섭취할 음식의 인덱스, 없으면 -1 반환(단, 인덱스는 1부터)
*/
/* ----------<알고리즘: o(k)>----------
가장 기본적인 알고리즘 - 시간 초과
하나씩 1씩 깎아나가기(0인 곳은 건너뛰기)
다음 음식은 바로 다음이 아니라 현재 음식을 찾아 번호 출력
한번만 순회해도 효율성 테스트 실패

전체 음식이 k보다 큰 경우 -> 섭취해야할 음식이 없다고 미리 판단할 수 있다. 그러나 전체 순회해야 할 수 있다. 


while k > 0: //k초 동안 음식 섭취
-> 1 이상의 음식들만 깎는다.
-> 이미 음식 소진 다 했을 경우 무한 루프에 빠지게 된다.
-> basecase: 음식이 하나도 안 남음을 인지하고 빠져나가야 한다.
    -> 미리 한번 순회해서 파악해놔야겠다. sum < k 판단하여 시작 전에 바로 결과 반환
    
이후 섭취할 수 있는 음식 탐색
    1 이상의 음식이 발견되면 바로 인덱스 정보 얻고 break
*/
/* -----<주의할 것>-----
반복문에서 항상 basecase를 고려해야 한다.
조건에 쓰인 변수가 반복문 내부에서 basecase에 닿도록 처리문을 써줘야 한다.
*/
/* -----<새롭게 안 것>-----
세그멘테이션 폴트는 무한루프가 발생할 때도 오류를 뱉는다.
*/
/* -----<채점 결과>-----
정확성: 32/32
효율성: 0/8
*/
#include <string>
#include <vector>

using namespace std;

int solution(vector<int> food_times, long long k) {
    int answer = 0;
    int fsz = food_times.size();
    int sum = 0;    // 전체 음식 양
    int i = 0;      // 음식 벡터 인덱스
    // k 초 이후에 섭취할 음식이 없을지 미리 음식양을 파악하여 판단
    for(int i = 0; i < fsz; i++){
        sum += food_times[i];
    }
    if( sum <= k )
        return -1;
    
    // k 초
    while(k > 0){
        if(food_times[i % fsz] > 0){  // 섭취할 음식이 있으면 섭취
            food_times[i % fsz]--;
            k--;
        }
        i++;   
    }
    // k 초 후 섭취할 음식 탐색
    while(1){
        if(food_times[i % fsz] > 0){
            answer = (i % fsz) + 1;
            break;
        }           
        i++;
    }
    return answer;
}