/* ----------<문제 정의>----------
문제: 괄호 처리와 괄호 영역간에 별도 계산을 위한 스택 자료구조 이용
입력: 괄호 문자열
출력: 괄호 영역별로 계산한 잘려진 쇠막대기 조각 개수
시간 제한: 1초
주의 사항: 구현 패턴화
*/
/* ----------<시간초과 알고리즘>----------
처음 스택 연산 과정을 구체화함. 결국 괄호가 얼마나 열려있는지 개수를 파악해야 종료 시점을 알 수 있음.
그러면 괄호의 종류도 하나이니까, 애초에 변수를 이용해보자.
변수로 하면 영역안의 영역을 표현하기 어려워짐. 
예를 들어, ((())) (())) 에서 두번째 레이저를 포함하고 있는 두 번째 쇠막대기 영역은 별도로 계산해주어야 한다.
기존의 bracket이나 razor에 합치면 구분이 되지 않는 문제가 발생한다.
따라서 스택 자료구조를 이용하되 bracket 변수를 이용하여 스택에 괄호가 몇개가 존재하는지 파악하면 될 것 같다.

'(' 입력

')' 입력
    이전 입력이 '('이면 레이저
        이전의 '(' pop하고, 스택에 레이저 표시 * 추가
    아니면
        '(' 나올 때까지(해당 영역의 razor 개수를 알기 위해)
            razor 개수 파악
        '(' pop
        누적 쇠막대기 개수에 razor+1 더하기
        razor 개수 만큼 스택에 * 추가 (다음 레벨의 쇠막대기 계산에 쓰기 위해)
        bracket 개수가 0이면 스택 초기화(더 이상 그 영역에 겹쳐진 막대기가 없다는 의미이기 때문)
*/

#include <iostream>
#include <stack>
#include <string>
using namespace std;
int main(){
    string pts;
    stack<char> st;
    cin >> pts;
    int ptslen = pts.length();
    int bracket = 0;    // 열린 괄호 개수
    int sum = 0;    // 잘린 막대기 수
    for(int i = 0; i < ptslen; i++){
        if(pts[i] == '(' ){
            bracket++;
            st.push('(');
        }
        else if(pts[i] == ')'){
            if(pts[i-1] == '('){  // 레이저 파악. 옳은 괄호 형태만 들어온다고 가정하고 이전 인덱스 접근
                st.pop();
                st.push('*');
            }
            else{
                // 해당 쇠막 대기 영역 안의 레이저 개수 파악
                bracket--;  // 열린 괄호 하나 소거
                int razor = 0;
                while(st.top() != '('){
                    razor++;
                    st.pop();
                    // 스택에는 ')' 가 없음. 즉시 처리하기 때문. *만 처리
                }
                st.pop();   // '(' pop처리
                sum += (razor+1);
                while(razor > 0){
                    st.push('*');
                    razor--;
                }
                if(bracket == 0){   // 열린 괄호가 더 이상 없을 때 겹쳐진 막대기가 더 이상 없음을 의미
                    // stack 초기화
                    while(!st.empty())
                        st.pop();
                }
            }
        }
    }
    cout << sum;
}