/* ----------<알고리즘>----------
문제: 스택으로 만들 수 있는 수열 판단
입력: n, n개의 수 (n은 10만 이하)
출력: 가능할 시 연산자/ NO
*/
/* ----------<알고리즘>----------
입력받은 수열을 하나씩 확인하면서 1~n 순서대로 stack 연산
즉, 입력받은 수열이 나오도록 스택 연산 시행
입력받은 수에 대해 현재 까지 스택에 넣은 수가 작으면 그 수가 나올 때까지 입력받기

i는 1~n 순서의 입력 수열
arr[p]는 스택으로 만들 수 있는지 확인이 필요한 수열
하나의 p가 여러개의 i를 커버하게 되므로 p를 기준으로 while 조건문을 만든다.
*/
/* -----<예외 케이스>-----
입력받은 수열 각각에 대해 1~n을 순서대로 처리해주기 위해 for문으로 구현한다면 
n까지 도달했을 때 한번만 처리해주고 반복되는 스택 작업을 처리할 수 없게된다.
5
1
2
5
3
4
예상 결과: NO
실행 결과:
+
-
+
+
+
-

🧐그래서 do~while로 바꿔본다.
*/
/* -----<시간 초과>-----
알고리즘 복잡도를 계산하면 O(N)으로 추측됨.
따라서 무한 루프에 빠지는 예외 케이스가 존재한다고 생각됨

@ 무한루프에 빠지는 지 확인(while 조건-i기준 vs p기준 확인) => 무한루프 X
    ex1) i가 p보다 먼저 끝까지 간 상황
    1 2 3
    2 3 1
    i가 4인 상황에서 p는 3번째에 와있음. 정상 범위를 벗어난 i값을 stack에 넣게 되는 가능성이 있나?
        -> else 조건(i > arr[p])에 걸리므로 stack에 있는 값과 비교하여 pop하는 과정이 발생한다.
        -> arr[p] 에는 4이상의 값이 없으므로 지속하여 stack에 있는 값하고만 처리를 하므로 top의 값과 일치해서 pop되거나
            나올 수 없는 수이면 끝나게 된다.
    p가 아직 n보다 작은 상황이므로 여전히 while문 안에서 처리되어야 하는 상황이 맞음.

    ex2) p가 i보다 먼저 끝까지 간 상황은 있을 수 없음. 동시에는 가능 
        -> 그러므로 p를 기준으로 while문 조건을 구성하는게 맞음
    1 2 3
    3 1 2

☝ 문제 원인은 cout << endl. -> \n 으로 바꿔주어 해결
*/
/* -----<새롭게 안 것>-----
endl은 버퍼를 비우기 때문에 느리다.
*/
#include <iostream>
#include <string>
#include <stack>
using namespace std;
int main(){
    ios_base::sync_with_stdio;
    cin.tie(NULL);
    cout.tie(NULL);
    int n, num, p = 0;
    string op;
    int arr[100001];
    stack<int> st;
    // 수열 입력 받기
    cin >> n;
    for(int i = 0; i < n; i++){
        cin >> num;
        arr[i] = num;
    }
    int i = 1;
    // 1~n 순서의 수열과 입력된 수열을 하나씩 비교한다.
    do{
        if(i < arr[p]){ // i는 항상 arr[p]보다 작거나 같다. 하지만 i는 p보다 크거나 같다.
            st.push(i++);
            op+='+';
        }
        else if(i == arr[p]){
            st.push(i++);
            op+='+';
            st.pop();
            op+='-';
            p++;
        }
        else{   // i > arr[p]
            if(st.top() == arr[p]){
                st.pop();
                op+='-';
                p++;
            } 
            else {
                cout << "NO";
                return 0;
            }
        }      
    }while(p < n);
    for(i = 0; i < op.length(); i++)
        cout << op[i] << '\n';
}